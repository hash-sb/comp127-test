(generated by ChatGPT, see instructor notes for prompt)

# Assignment: Thinking Like a Tester — Unit Testing Concepts (Intro Java)

**Course:** CS1/Intro to Java
**Focus:** Concepts of unit testing (not JUnit mechanics)
**Suggested time:** ~90–120 minutes

---

## Why you’re doing this
Writing tests is not just about getting green checkmarks. It’s about *thinking clearly about behavior*. In this assignment you will:

- Design tests from a specification (equivalence classes & boundaries).
- Read code to predict behavior and expose flaws.
- Reason about coverage (statement/branch) and why 100% coverage is not enough.
- See how good tests can still miss bugs because of edge cases, weak oracles, or ambiguous specs.
- Practice tiny refactors that make code more testable.

We’ll keep Java/JUnit details light: you may express tests as plain English test ideas, pseudo-Java using `assert`, or JUnit-like pseudocode such as `assertEquals(expected, actual)`. Credit is for your *testing reasoning*, not for API memorization.

---

## What to submit
Submit a single Markdown file named **`testing-concepts.md`** containing:

1. Your answers, explanations, and test designs for each exercise.
2. Any tiny code snippets you write (embed them in fenced code blocks).
3. A short reflection at the end (prompts below).

*(If you prefer, you may also include small `.java` files, but this is optional.)*

---

## Grading & assessment
Your work will be assessed on:

- **Test design quality (40%)** – Clear equivalence classes, boundary analysis, purposeful cases, and ability to detect logic flaws.
- **Code reading & explanation (30%)** – Accurate reasoning about what the given code does and why it fails.
- **Use of coverage concepts (15%)** – Correct application of statement vs. branch coverage and articulation of their limits.
- **Clarity & organization (10%)** – Well-structured, concise writing; readable code snippets.
- **Reflection (5%)** – Thoughtful takeaways and next steps.

Rubric hints:
- *Excellent* answers justify test choices, connect tests to specific risks, and clearly distinguish behavior vs. implementation.
- *Satisfactory* answers list tests but with limited justification.
- *Needs work* answers focus on happy paths, miss boundaries, or confuse coverage with correctness.

Academic integrity: You may discuss ideas with classmates; write your own tests and explanations. If you used AI or other resources to brainstorm, briefly note **what** you used and **how** it helped.

---

## Conventions for this assignment
- You can write tests as *ideas* (e.g., “`clamp(5,0,10)` returns `5`” and “values below `lo` map to `lo`”).
- When you show code, keep it short and focused. You may use plain `assert` in Java or pseudo-assertions.

---

## Exercise 1 — Designing tests from a spec (equivalence classes & boundaries)

**Function spec:**

> `clamp(x, lo, hi)` returns `x` if `lo ≤ x ≤ hi`; returns `lo` if `x < lo`; returns `hi` if `x > hi`. Assume integers. Behavior is **undefined** if `lo > hi`.

**Tasks:**
1. Identify **equivalence classes** for inputs `(x, lo, hi)` that lead to *different* behavior. Include boundary points.
2. Propose a **minimal** set of test cases that gives high confidence you covered the meaningful behavior. Label each test with the class/boundary it represents and why it is necessary.
3. Suppose an implementation silently swaps `lo` and `hi` when `lo > hi` (even though the spec says behavior is undefined). Explain how your tests would or would not reveal this divergence from the spec.
4. Write either (a) test ideas in English, or (b) a few Java-like assertions. Example style:

```
// idea-style or pseudo-Java; any clear format is fine
assert clamp(5, 0, 10) == 5;   // inside range
assert clamp(-3, 0, 10) == 0;  // below lo boundary
assert clamp(11, 0, 10) == 10; // above hi boundary
```

**Concept emphasis:** *Derive tests from behavior, not from the code you wish existed.*

---

## Exercise 2 — Missed test cases & coverage blindspots

Consider the following implementation:

```
int sign(int x) {
    if (x > 0) return 1;
    else return -1;
}
```

**Tasks:**
1. Achieve **100% statement coverage** for this function. List the smallest set of inputs you’d use.
2. Does that set actually validate the **spec** of a sign function (which should return `-1` for negatives, `0` for zero, and `1` for positives)? If not, what did you miss?
3. Propose tests that capture the intended behavior, including boundaries, and explain how they differ from the coverage-only set.
4. Provide a 1–2 line fix to the code and show that your tests pass with the fix.

**Takeaway:** *Coverage can tell you where you’ve looked, not whether you looked for the right things.*

---

## Exercise 3 — 100% coverage is not sufficient (edge-case bug)

Consider:

```
int abs(int x) {
    return (x < 0) ? -x : x;
}
```

**Tasks:**
1. Provide tests that achieve **100% branch coverage**.
2. Show that the function is still **incorrect** for at least one input. Identify the input and explain the failure.
3. Add a test that would catch this bug.
4. Write a corrected version `safeAbs` that handles the problematic input while preserving behavior for other integers. Keep it short and explain your approach.

*Hint:* Consider the limits of 32-bit signed `int`.

**Concept emphasis:** *Even perfect coverage doesn’t guarantee correct or robust behavior; choose test inputs thoughtfully.*

---

## Exercise 4 — Reading code to expose a subtle logic bug

Here’s a leap-year checker:

```
boolean isLeapYear(int y) {
    if (y % 4 != 0) return false;
    if (y % 100 == 0) return true;   // BUG: centuries are not leap years unless divisible by 400
    if (y % 400 == 0) return true;
    return true;
}
```

**Tasks:**
1. Propose a concise test suite (5–7 tests) that would **fail** on this implementation but **pass** on a correct one. Include historically relevant years.
2. State a **property** of leap years (in words or pseudo-logic) that your tests collectively approximate.
3. Fix the function in 3–4 lines.
4. *Mutation thought experiment:* Suppose a “mutant” version changes the second line to `if (y % 100 == 0) return false;` but accidentally removes the `y % 400` check. Which of your tests “kills” this mutant and why?

**Concept emphasis:** *Good example-based tests + a stated property make bugs easier to pinpoint.*

---

## Exercise 5 — Good tests, still wrong: spec ambiguity & oracles

**Spec:** `medianOfThree(a, b, c)` returns “the middle value.” The spec doesn’t say what to do with duplicates.

Candidate implementation A:
```
int medianOfThree(int a, int b, int c) {
    if ((a <= b && b <= c) || (c <= b && b <= a)) return b;
    if ((b <= a && a <= c) || (c <= a && a <= b)) return a;
    return c;
}
```
Implementation B (different tie behavior):
```
int medianOfThree(int a, int b, int c) {
    int[] xs = {a, b, c};
    java.util.Arrays.sort(xs);
    return xs[1]; // sorts are stable but ties may pick different representative values
}
```

**Tasks:**
1. Write 6–8 tests that reflect *your interpretation* of the spec, including cases with duplicates.
2. Show how both implementations can pass your tests *if* your oracle is weak/ambiguous. Identify the holes.
3. Propose a **clarified spec** (2–3 sentences) that removes ambiguity (e.g., “when duplicates exist, return that duplicate value”).
4. Update your test suite so that exactly one of A or B fails (choose which) under the clarified spec. Explain why.

**Concept emphasis:** *Tests are only as strong as their oracle/spec.*

---

## Exercise 6 — Tiny refactor for testability (isolation & determinism)

Functions that read the clock, file system, or random numbers can be hard to test. Consider this method:

```
// Returns seconds remaining until targetHour (0–23) from the current system time.
int secondsUntil(int targetHour) {
    java.time.LocalTime now = java.time.LocalTime.now();
    int nowSec = now.toSecondOfDay();
    int targetSec = java.time.LocalTime.of(targetHour, 0).toSecondOfDay();
    int delta = targetSec - nowSec;
    return (delta >= 0) ? delta : (24*3600 + delta);
}
```

**Tasks:**
1. Explain why tests for this function could be **flaky**.
2. Refactor the signature to accept a time source (e.g., `Clock` or a function parameter) so the function becomes deterministic in tests. Show the new method in ~5–8 lines.
3. Write two clear tests (English or pseudo-assertions) that verify behavior using a **fake** or fixed time source.

**Concept emphasis:** *Small design changes (dependency injection) make code testable and tests reliable.*

---

## Reflection (5–8 sentences)
- Which exercise changed how you think about testing, and why?
- Give an example where coverage **helped** you and one where it **didn’t**.
- Name one additional technique you’d like to try next time (e.g., property-based testing, mutation testing, fuzzing).
- What is one habit you will adopt when designing tests for future assignments?

---

## (Optional) Quick reference: coverage vocabulary
- **Statement coverage:** every executable statement ran at least once.
- **Branch coverage:** every true/false branch evaluated at least once.
- **Path coverage:** every possible path executed (usually infeasible for nontrivial code).
- **Mutation testing (idea):** introduce small code changes (“mutants”) and see whether tests fail; surviving mutants indicate weak tests.

---

## Submission checklist
- [ ] Clear equivalence classes & boundary tests for `clamp`
- [ ] Identified coverage blindspot in `sign` and fixed it
- [ ] Demonstrated a bug despite 100% coverage in `abs`
- [ ] Exposed and fixed the leap-year bug; killed a mutant
- [ ] Resolved spec ambiguity for `medianOfThree` with tests
- [ ] Refactored `secondsUntil` for determinism with tests
- [ ] Reflection written
- [ ] File is named `testing-concepts.md` and is readable

---

### Friendly reminder
Green bars are satisfying, but correctness comes from *careful thinking about behavior*. Your goal is to become the kind of developer whose tests catch your own bugs—before your users do.
